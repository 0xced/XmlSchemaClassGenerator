using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Schema;
using System.Xml.Serialization;

namespace XmlSchemaClassGenerator
{
    public class Generator
    {
        public Func<string, string> GenerateNamespaceName { get; set; }
        public Dictionary<string, string> NamespaceMapping { get; set; }
        public string OutputFolder { get; set; }
        public Action<string> Log { get; set; }

        public bool GenerateNullables
        {
            get
            {
                return PropertyModel.GenerateNullables;
            }

            set
            {
                PropertyModel.GenerateNullables = value;
            }
        }

        private XmlSchemaSet Set = new XmlSchemaSet();
        private Dictionary<XmlQualifiedName, XmlSchemaAttributeGroup> AttributeGroups;
        private Dictionary<string, NamespaceModel> Namespaces = new Dictionary<string, NamespaceModel>();
        private static XmlQualifiedName AnyType = new XmlQualifiedName("anyType", XmlSchema.Namespace);

        public void Generate(IEnumerable<string> files)
        {
            var schemas = files.Select(f => XmlSchema.Read(XmlReader.Create(f), (s, e) =>
            {
                Trace.TraceError(e.Message);
            }));

            foreach (var s in schemas)
            {
                Set.Add(s);
            }

            Set.Compile();

            BuildModel();

            var namespaces = GenerateCode();

            var provider = new Microsoft.CSharp.CSharpCodeProvider();

            foreach (var ns in namespaces)
            {
                var compileUnit = new CodeCompileUnit();
                compileUnit.Namespaces.Add(ns);

                var title = ((AssemblyTitleAttribute)Attribute.GetCustomAttribute(Assembly.GetExecutingAssembly(),
                    typeof(AssemblyTitleAttribute))).Title;
                var version = Assembly.GetExecutingAssembly().GetName().Version.ToString();

                ns.Comments.Add(new CodeCommentStatement(string.Format("This code was generated by {0} version {1}.", title, version)));

                using (StringWriter sw = new StringWriter())
                {
                    provider.GenerateCodeFromCompileUnit(compileUnit, sw, new CodeGeneratorOptions { VerbatimOrder = true, BracingStyle = "C" });
                    var s = sw.ToString().Replace("};", "}"); // remove ';' at end of automatic properties
                    var path = Path.Combine(OutputFolder, ns.Name + ".cs");
                    if (Log != null) Log(path);
                    File.WriteAllText(path, s);
                }
            }
        }

        private IEnumerable<CodeNamespace> GenerateCode()
        {
            return Namespaces.Values.Select(n => n.Generate());
        }

        private string BuildNamespace(string xmlNamespace)
        {
            if (NamespaceMapping != null && NamespaceMapping.ContainsKey(xmlNamespace)) return NamespaceMapping[xmlNamespace];
            if (GenerateNamespaceName != null) return GenerateNamespaceName(xmlNamespace);
            
            throw new Exception(string.Format("Namespace {0} not in namespace map and GenerateNamespaceName not provided.", xmlNamespace));
        }

        private static Dictionary<char, string> InvalidChars = CreateInvalidChars();

        private static Dictionary<char, string> CreateInvalidChars()
        {
            var invalidChars = new Dictionary<char, string>();

            invalidChars['\x00'] = "Null";
            invalidChars['\x01'] = "StartOfHeading";
            invalidChars['\x02'] = "StartOfText";
            invalidChars['\x03'] = "EndOfText";
            invalidChars['\x04'] = "EndOfTransmission";
            invalidChars['\x05'] = "Enquiry";
            invalidChars['\x06'] = "Acknowledge";
            invalidChars['\x07'] = "Bell";
            invalidChars['\x08'] = "Backspace";
            invalidChars['\x09'] = "HorizontalTab";
            invalidChars['\x0A'] = "LineFeed";
            invalidChars['\x0B'] = "VerticalTab";
            invalidChars['\x0C'] = "FormFeed";
            invalidChars['\x0D'] = "CarriageReturn";
            invalidChars['\x0E'] = "ShiftOut";
            invalidChars['\x0F'] = "ShiftIn";
            invalidChars['\x10'] = "DataLinkEscape";
            invalidChars['\x11'] = "DeviceControl1";
            invalidChars['\x12'] = "DeviceControl2";
            invalidChars['\x13'] = "DeviceControl3";
            invalidChars['\x14'] = "DeviceControl4";
            invalidChars['\x15'] = "NegativeAcknowledge";
            invalidChars['\x16'] = "SynchronousIdle";
            invalidChars['\x17'] = "EndOfTransmissionBlock";
            invalidChars['\x18'] = "Cancel";
            invalidChars['\x19'] = "EndOfMedium";
            invalidChars['\x1A'] = "Substitute";
            invalidChars['\x1B'] = "Escape";
            invalidChars['\x1C'] = "FileSeparator";
            invalidChars['\x1D'] = "GroupSeparator";
            invalidChars['\x1E'] = "RecordSeparator";
            invalidChars['\x1F'] = "UnitSeparator";
            //invalidChars['\x20'] = "Space";
            invalidChars['\x21'] = "ExclamationMark";
            invalidChars['\x22'] = "Quote";
            invalidChars['\x23'] = "Hash";
            invalidChars['\x24'] = "Dollar";
            invalidChars['\x25'] = "Percent";
            invalidChars['\x26'] = "Ampersand";
            invalidChars['\x27'] = "SingleQuote";
            invalidChars['\x28'] = "LeftParenthesis";
            invalidChars['\x29'] = "RightParenthesis";
            invalidChars['\x2A'] = "Asterisk";
            invalidChars['\x2B'] = "Plus";
            invalidChars['\x2C'] = "Comma";
            //invalidChars['\x2D'] = "Minus";
            invalidChars['\x2E'] = "Period";
            invalidChars['\x2F'] = "Slash";
            invalidChars['\x3A'] = "Colon";
            invalidChars['\x3B'] = "Semicolon";
            invalidChars['\x3C'] = "LessThan";
            invalidChars['\x3D'] = "Equal";
            invalidChars['\x3E'] = "GreaterThan";
            invalidChars['\x3F'] = "QuestionMark";
            invalidChars['\x40'] = "At";
            invalidChars['\x5B'] = "LeftSquareBracket";
            invalidChars['\x5C'] = "Backslash";
            invalidChars['\x5D'] = "RightSquareBracket";
            invalidChars['\x5E'] = "Caret";
            //invalidChars['\x5F'] = "Underscore";
            invalidChars['\x60'] = "Backquote";
            invalidChars['\x7B'] = "LeftCurlyBrace";
            invalidChars['\x7C'] = "Pipe";
            invalidChars['\x7D'] = "RightCurlyBrace";
            invalidChars['\x7E'] = "Tilde";
            invalidChars['\x7F'] = "Delete";

            return invalidChars;
        }

        private static Regex InvalidCharsRegex = CreateInvalidCharsRegex();

        private static Regex CreateInvalidCharsRegex()
        {
            var r = string.Join("", InvalidChars.Keys.Select(c => string.Format(@"\x{0:x2}", (int)c)).ToArray());
            return new Regex("[" + r + "]", RegexOptions.Compiled);
        }

        private static CodeDomProvider Provider = new Microsoft.CSharp.CSharpCodeProvider();
        public static string MakeValidIdentifier(string s)
        {
            var id = InvalidCharsRegex.Replace(s, m => InvalidChars[m.Value[0]]);
            return Provider.CreateValidIdentifier(Regex.Replace(id, @"\W+", "_"));
        }

        public static string ToTitleCase(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;
            return MakeValidIdentifier(char.ToUpperInvariant(s[0]) + s.Substring(1));
        }

        private void BuildModel()
        {
            AttributeGroups = Set.Schemas().Cast<XmlSchema>().SelectMany(s => s.AttributeGroups.Values.Cast<XmlSchemaAttributeGroup>()).ToDictionary(g => g.QualifiedName);

            foreach (var rootElement in Set.GlobalElements.Values.Cast<XmlSchemaElement>())
            {
                var qualifiedName = rootElement.ElementSchemaType.QualifiedName;
                if (qualifiedName.IsEmpty) qualifiedName = rootElement.QualifiedName;
                var type = CreateTypeModel(rootElement.ElementSchemaType, qualifiedName);

                if (type.RootElementName != null)
                {
                    // There is already another global element with this type.
                    // Need to create an empty derived class.

                    if (!(type is ClassModel))
                        throw new Exception(string.Format("Multiple root elements for single simple type not supported: {0}.", rootElement.QualifiedName));

                    var derivedClassModel = new ClassModel
                    {
                        Name = ToTitleCase(rootElement.QualifiedName.Name),
                        Namespace = CreateNamespaceModel(rootElement.QualifiedName)
                    };

                    derivedClassModel.Documentation.AddRange(GetDocumentation(rootElement));

                    if (derivedClassModel.Namespace != null)
                        derivedClassModel.Namespace.Types[derivedClassModel.Name] = derivedClassModel;

                    TypeModel.Types[rootElement.QualifiedName] = derivedClassModel;

                    derivedClassModel.BaseClass = (ClassModel)type;
                    derivedClassModel.BaseClass.DerivedTypes.Add(derivedClassModel);

                    derivedClassModel.RootElementName = rootElement.QualifiedName;
                }
                else
                {
                    type.RootElementName = rootElement.QualifiedName;
                }
            }

            foreach (var globalType in Set.GlobalTypes.Values.Cast<XmlSchemaType>())
            {
                var type = CreateTypeModel(globalType);
            }
        }

        private TypeModel CreateTypeModel(XmlSchemaType type, XmlQualifiedName qualifiedName = null)
        {
            if (qualifiedName == null) qualifiedName = type.QualifiedName;

            TypeModel typeModel = null;
            if (!qualifiedName.IsEmpty && TypeModel.Types.TryGetValue(qualifiedName, out typeModel)) return typeModel;

            var namespaceModel = CreateNamespaceModel(qualifiedName);

            var docs = GetDocumentation(type);

            var complexType = type as XmlSchemaComplexType;
            if (complexType != null)
            {
                var classModel = new ClassModel
                {
                    Name = ToTitleCase(qualifiedName.Name),
                    Namespace = namespaceModel,
                    XmlSchemaName = qualifiedName,
                    XmlSchemaType = type,
                    IsAbstract = complexType.IsAbstract,
                    IsAnonymous = type.QualifiedName.Name == "",
                };

                classModel.Documentation.AddRange(docs);

                if (namespaceModel != null)
                {
                    namespaceModel.Types[classModel.Name] = classModel;
                }

                if (!qualifiedName.IsEmpty) TypeModel.Types[qualifiedName] = classModel;

                if (complexType.BaseXmlSchemaType != null && complexType.BaseXmlSchemaType.QualifiedName != AnyType)
                {
                    var baseModel = CreateTypeModel(complexType.BaseXmlSchemaType);
                    if (!(baseModel is ClassModel)) throw new Exception(string.Format("Derivation of class {0} from simple type not supported.", classModel.Name));
                    classModel.BaseClass = (ClassModel)baseModel;
                    classModel.BaseClass.DerivedTypes.Add(classModel);
                }

                var particle = classModel.BaseClass != null ? ((XmlSchemaComplexContentExtension)complexType.ContentModel.Content).Particle
                    : complexType.ContentTypeParticle;
                var items = GetElements(particle);

                // ElementSchemaType must be non-null. This is not the case when maxOccurs="0".
                foreach (var item in items.Where(i => i.ElementSchemaType != null))
                {
                    var elementQualifiedName = item.ElementSchemaType.QualifiedName;

                    if (elementQualifiedName.IsEmpty)
                    {
                        elementQualifiedName = item.QualifiedName;

                        if (elementQualifiedName.IsEmpty || elementQualifiedName.Namespace == "")
                        {
                            // inner type, have to generate a type name
                            var name = ToTitleCase(classModel.Name) + ToTitleCase(item.QualifiedName.Name);
                            elementQualifiedName = new XmlQualifiedName(name, qualifiedName.Namespace);
                            // try to avoid name clashes
                            if (NameExists(elementQualifiedName)) elementQualifiedName = new[] { "Item", "Property", "Element" }
                                .Select(s => new XmlQualifiedName(elementQualifiedName.Name + s, elementQualifiedName.Namespace))
                                .First(n => !NameExists(n));
                        }
                    }

                    var propertyName = ToTitleCase(item.QualifiedName.Name);
                    if (propertyName == classModel.Name) propertyName += "Property"; // member names cannot be the same as their enclosing type

                    var property = new PropertyModel
                    {
                        OwningType = classModel,
                        XmlSchemaName = item.QualifiedName,
                        Name = propertyName,
                        Type = CreateTypeModel(item.ElementSchemaType, elementQualifiedName),
                        IsNillable = item.IsNillable,
                        IsNullable = item.MinOccurs < 1.0m,
                        IsCollection = item.MaxOccurs > 1.0m || particle.MaxOccurs > 1.0m, // http://msdn.microsoft.com/en-us/library/vstudio/d3hx2s7e(v=vs.100).aspx
                        DefaultValue = item.DefaultValue,
                        Form = item.Form == XmlSchemaForm.None ? item.GetSchema().ElementFormDefault : item.Form,
                        XmlNamespace = item.QualifiedName.Namespace != "" && item.QualifiedName.Namespace != qualifiedName.Namespace ? item.QualifiedName.Namespace : null,
                    };

                    var itemDocs = GetDocumentation(item);
                    property.Documentation.AddRange(itemDocs);

                    property.IsDeprecated = itemDocs.Any(d => d.Text.StartsWith("DEPRECATED"));

                    classModel.Properties.Add(property);
                }

                var attributes = classModel.BaseClass != null ? ((XmlSchemaComplexContentExtension)complexType.ContentModel.Content).Attributes
                    : complexType.Attributes;
                foreach (var attribute in attributes.OfType<XmlSchemaAttribute>()
                    .Concat(attributes.OfType<XmlSchemaAttributeGroupRef>().SelectMany(r => AttributeGroups[r.RefName].Attributes.Cast<XmlSchemaAttribute>()))
                    .Where(a => a.Use != XmlSchemaUse.Prohibited))
                {
                    var attributeName = ToTitleCase(attribute.QualifiedName.Name);
                    if (attributeName == classModel.Name) attributeName += "Property"; // member names cannot be the same as their enclosing type

                    var property = new PropertyModel
                    {
                        OwningType = classModel,
                        Name = attributeName,
                        XmlSchemaName = attribute.QualifiedName,
                        Type = CreateTypeModel(attribute.AttributeSchemaType),
                        IsAttribute = true,
                        IsNullable = attribute.Use != XmlSchemaUse.Required,
                        DefaultValue = attribute.DefaultValue,
                        Form = attribute.Form == XmlSchemaForm.None ? attribute.GetSchema().AttributeFormDefault : attribute.Form,
                        XmlNamespace = attribute.QualifiedName.Namespace != "" && attribute.QualifiedName.Namespace != qualifiedName.Namespace ? attribute.QualifiedName.Namespace : null,
                    };

                    var attributeDocs = GetDocumentation(attribute);
                    property.Documentation.AddRange(attributeDocs);

                    classModel.Properties.Add(property);
                }

                return classModel;
            }

            var simpleType = type as XmlSchemaSimpleType;
            if (simpleType != null)
            {
                var restrictions = new List<RestrictionModel>();

                var typeRestriction = simpleType.Content as XmlSchemaSimpleTypeRestriction;
                if (typeRestriction != null)
                {
                    if (typeRestriction.BaseTypeName.Name == "string")
                    {
                        var enumFacets = typeRestriction.Facets.OfType<XmlSchemaEnumerationFacet>();
                        if (enumFacets.Any())
                        {
                            // we got an enum
                            var enumModel = new EnumModel
                            {
                                Name = ToTitleCase(qualifiedName.Name),
                                Namespace = namespaceModel,
                                XmlSchemaName = qualifiedName,
                                XmlSchemaType = type,
                            };

                            enumModel.Documentation.AddRange(docs);

                            foreach (var facet in enumFacets)
                            {
                                var value = new EnumValueModel
                                {
                                    Name = ToTitleCase(facet.Value),
                                    Value = facet.Value
                                };

                                var valueDocs = GetDocumentation(facet);
                                value.Documentation.AddRange(valueDocs);

                                var deprecated = facet.Annotation == null ? false : facet.Annotation.Items.OfType<XmlSchemaAppInfo>()
                                    .Any(a => a.Markup.Any(m => m.Name == "annox:annotate" && m.HasChildNodes && m.FirstChild.Name == "jl:Deprecated"));
                                value.IsDeprecated = deprecated;

                                enumModel.Values.Add(value);
                            }

                            if (namespaceModel != null)
                            {
                                namespaceModel.Types[enumModel.Name] = enumModel;
                            }

                            if (!qualifiedName.IsEmpty) TypeModel.Types[qualifiedName] = enumModel;

                            return enumModel;
                        }
                    }

                    restrictions = typeRestriction.Facets.Cast<XmlSchemaFacet>().Select(f => GetRestriction(simpleType, f)).ToList();
                }

                var simpleModel = new SimpleModel
                {
                    Name = ToTitleCase(qualifiedName.Name),
                    Namespace = namespaceModel,
                    XmlSchemaName = qualifiedName,
                    XmlSchemaType = type,
                    ValueType = simpleType.Datatype.ValueType,
                };

                simpleModel.Documentation.AddRange(docs);
                simpleModel.Restrictions.AddRange(restrictions);

                if (namespaceModel != null)
                {
                    namespaceModel.Types[simpleModel.Name] = simpleModel;
                }

                if (!qualifiedName.IsEmpty) TypeModel.Types[qualifiedName] = simpleModel;

                return simpleModel;
            }

            throw new Exception(string.Format("Cannot build declaration for {0}", qualifiedName));
        }

        private NamespaceModel CreateNamespaceModel(XmlQualifiedName qualifiedName)
        {
            NamespaceModel namespaceModel = null;
            if (!qualifiedName.IsEmpty && qualifiedName.Namespace != XmlSchema.Namespace)
            {
                if (!Namespaces.TryGetValue(qualifiedName.Namespace, out namespaceModel))
                {
                    var namespaceName = BuildNamespace(qualifiedName.Namespace);
                    namespaceModel = new NamespaceModel { Name = namespaceName, XmlSchemaNamespace = qualifiedName.Namespace };
                    Namespaces[qualifiedName.Namespace] = namespaceModel;
                }
            }
            return namespaceModel;
        }

        private bool NameExists(XmlQualifiedName name)
        {
            var elements = Set.GlobalElements.Names.Cast<XmlQualifiedName>();
            var types = Set.GlobalTypes.Names.Cast<XmlQualifiedName>();
            return elements.Concat(types).Any(n => n.Namespace == name.Namespace && name.Name.Equals(n.Name, StringComparison.OrdinalIgnoreCase));
        }

        private RestrictionModel GetRestriction(XmlSchemaSimpleType type, XmlSchemaFacet facet)
        {
            if (facet is XmlSchemaMaxLengthFacet)
                return new MaxLengthRestrictionModel { Value = int.Parse(facet.Value) };
            if (facet is XmlSchemaMinLengthFacet)
                return new MinLengthRestrictionModel { Value = int.Parse(facet.Value) };
            if (facet is XmlSchemaTotalDigitsFacet)
                return new TotalDigitsRestrictionModel { Value = int.Parse(facet.Value) };
            if (facet is XmlSchemaFractionDigitsFacet)
                return new FractionDigitsRestrictionModel { Value = int.Parse(facet.Value) };

            if (facet is XmlSchemaPatternFacet)
                return new PatternRestrictionModel { Value = facet.Value };

            var valueType = type.Datatype.ValueType;

            if (facet is XmlSchemaMinInclusiveFacet)
                return new MinInclusiveRestrictionModel { Value = facet.Value, Type = valueType };
            if (facet is XmlSchemaMinExclusiveFacet)
                return new MinExclusiveRestrictionModel { Value = facet.Value, Type = valueType };
            if (facet is XmlSchemaMaxInclusiveFacet)
                return new MaxInclusiveRestrictionModel { Value = facet.Value, Type = valueType };
            if (facet is XmlSchemaMaxExclusiveFacet)
                return new MaxExclusiveRestrictionModel { Value = facet.Value, Type = valueType };

            throw new Exception(string.Format("Restriction {0} not supported.", facet.GetType().Name));
        }

        public IEnumerable<XmlSchemaElement> GetElements(XmlSchemaGroupBase groupBase)
        {
            foreach (var item in groupBase.Items)
            {
                foreach (var element in GetElements(item))
                    yield return element;
            }
        }

        public IEnumerable<XmlSchemaElement> GetElements(XmlSchemaObject item)
        {
            var element = item as XmlSchemaElement;
            if (element != null) yield return element;

            var groupRef = item as XmlSchemaGroupRef;
            if (groupRef != null)
                foreach (var groupRefElement in GetElements(groupRef.Particle))
                    yield return groupRefElement;

            var itemGroupBase = item as XmlSchemaGroupBase;
            if (itemGroupBase != null)
                foreach (var groupBaseElement in GetElements(itemGroupBase))
                    yield return groupBaseElement;
        }

        public List<DocumentationModel> GetDocumentation(XmlSchemaAnnotated annotated)
        {
            if (annotated.Annotation == null) return new List<DocumentationModel>();

            return annotated.Annotation.Items.OfType<XmlSchemaDocumentation>()
                .Where(d => d.Markup != null && d.Markup.Any())
                .Select(d => new DocumentationModel { Language = d.Language, Text = new XText(d.Markup.First().InnerText).ToString() })
                .Where(d => !string.IsNullOrEmpty(d.Text))
                .ToList();
        }
    }
}
